theory SecureDrop
begin

// heuristic: o "./oracles/s2j_server_signature.py"

builtins: symmetric-encryption, asymmetric-encryption, signing, diffie-hellman

// KDF
functions: kdf/1

// Auth PKE
functions: AuthEnc/3, AuthDec/3
equations: AuthDec(pk(skS), skR, AuthEnc(skS, pk(skR), m)) = m

macros:
  2nd(m) = fst(snd(m)),
  3rd(m) = fst(snd(snd(m))),
  4th(m) = fst(snd(snd(snd(m)))),
  5th(m) = fst(snd(snd(snd(snd(m))))),
  6th(m) = fst(snd(snd(snd(snd(snd(m)))))),
  7th(m) = fst(snd(snd(snd(snd(snd(snd(m))))))),
  last7th(m) = snd(snd(snd(snd(snd(snd(m)))))),
  8th(m) = fst(snd(snd(snd(snd(snd(snd(snd(m)))))))),
  last9th(m) = snd(snd(snd(snd(snd(snd(snd(snd(m)))))))),

/*

Color semantics:

- Yellow (#FDFD96)      Key setup/distribution
- Red (#FF6961)         Adversary activity
- Light blue (#B4D9EF)  Message Fetching
- Dark blue (#6495ED)   Messaging
- Orange (#FF7F50)      Registration/Enrollment

 */

// Channel Rules

rule ClientOut[color=#FFFFFF]:
  [ Client_Out(~sess, $Server, msg), !Message_Server($Server) ]
  -->
  [ !Client(~sess, $Server, msg) ]

rule AdversaryClientOut[color=#FF6961]:
  [ In(~sess), In(msg), !Message_Server($Server) ]
  -->
  [ !Client(~sess, $Server, msg) ]

rule ServerOut[color=#FFFFFF]:
  [ Server_Out(~sess, $Server, msg), !Message_Server($Server) ]
  -->
  [ !Server(~sess, $Server, msg) ]

rule ClientToServer[color=#FFFFFF]:
  [ !Client(~sess, $Server, msg) ]
  -->
  [ Server_In(~sess, $Server, msg) ]

rule ServerToClient[color=#FFFFFF]:
  [ !Server(~sess, $Server, msg) ]
  -->
  [ Client_In(~sess, $Server, msg) ]

rule ServerToAdversaryClient[color=#FF6961]:
  [ In(adversarySess), !Server(adversarySess, $Server, msg) ]
  --[ AdversaryActivity() ]->
  [ Out(msg) ]

// Server Rules

rule Server_Ciphertext:
  [ Server_In(~sess, $Server, <'ciphertext', c>)]
  --[ Auto_Server_IN(~sess, $Server, <'ciphertext', c>) ]->
  [ !Stored_Ciphertext($Server, c)]

rule Server_Receive_Fetch_Request:
  [ Server_In(~sess, $Server, 'fetch_messages') ]
  -->
  [ Server_Fetched_Messages(~sess, $Server) ]

rule Server_Create_Challenge [derivchecks]:
  let me_pk = 'g'^~me_sk
      kmid = m_gdh^~re_sk
      pmgdh = me_pk^~re_sk
      enc_id = senc(~id, kmid)
  in
  [ Server_Fetched_Messages(~sess, $Server)
  , !Stored_Ciphertext($Server, <c, s_enc_pk, me_pk, m_gdh>)
  , Fr(~re_sk)
  , Fr(~id) ]
  --[ DHElement_Check(kmid)
    , DHElement_Check(me_pk)
    , DHElement_Check(pmgdh) ]->
  [ Stored_Ciphertext_Challenge($Server, ~sess, ~id, <c, s_enc_pk>)
  , Server_Out(~sess, $Server, <'challenge', <enc_id, pmgdh>>) ]

rule Server_Challenge_Response:
  [ Stored_Ciphertext_Challenge($Server, ~sess, ~id, <c, s_enc_pk>)
  , Server_In(~sess, $Server, <'solution', ~id>) ]
  -->
  [ Server_Out(~sess, $Server, <'ciphertext', <c, s_enc_pk>>)]

// Key Registration

rule Register_Newsroom_Key [color=#FF7F50]:
  let public_key = pk(~ltk) in
  [ Fr(~ltk) ]
  --[ OnlyOnce($A)
    , OnlyOnce($Server) ]->
  [ !Ltk_Newsroom($A, ~ltk)
  , !Pk_Newsroom($A, public_key)
  , !Newsroom_Server($A, $Server)
  , !Message_Server($Server)
  , Out(public_key) ]

rule Reveal_Newsroom_Key [color=#FF6961]:
  [ !Ltk_Newsroom(A, ~ltk) ]
  --[ Reveal_Newsroom_Key(A)
    , SomeCompromise() ]->
  [ Out(~ltk) ]

rule Register_Source_Keys [color=#FDFD96]:
  let s_enc_sk = kdf(<'Enc', ~passphrase>)
      s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      s_enc_pk = pk(s_enc_sk)
      s_fetch_pk = 'g'^s_fetch_sk
  in
  [ Fr(~passphrase) ]
  --[ Register_Source(s_enc_pk)
    , Register_Source_Fetch(s_fetch_pk)
    , OnlyOnce($A) ]->
  [ !Ltk_Source_Passphrase($A, ~passphrase)
  , Ltk_Source_Enc_Key_Reveal($A, s_enc_sk)
  , Ltk_Source_Fetch_Key_Reveal($A, s_fetch_sk)
  , Out(<s_enc_pk, s_fetch_pk>) ]

rule Reveal_Source_Enc_Key [color=#FF6961]:
  let s_enc_pk = pk(s_enc_sk)
  in
  [ Ltk_Source_Enc_Key_Reveal($A, s_enc_sk) ]
  --[ Reveal_Source_Enc_Key($A)
    , Reveal_Source_Enc_Key(s_enc_pk)
    , SomeCompromise() ]->
  [ Out(s_enc_sk) ]

rule Reveal_Source_Fetch_Key [color=#FF6961]:
  let s_fetch_pk = 'g'^s_fetch_sk
  in
  [ Ltk_Source_Fetch_Key_Reveal($A, s_fetch_sk) ]
  --[ Reveal_Source_Fetch_Key($A)
    , Reveal_Source_Fetch_Key(s_fetch_pk)
    , SomeCompromise() ]->
  [ Out(s_fetch_sk) ]

// Journalist Enrollment

rule Journalist_Enrollment [color=#FF7F50]:
  let j_sig_pk = pk(~j_sig_sk)
      j_fetch_pk = 'g'^~j_fetch_sk
      j_enc_pk = pk(~j_enc_sk)
      sig_j_pk = sign(<'signature', j_sig_pk, j_enc_pk, j_fetch_pk>, ~nr_sk)
  in
  [ !Ltk_Newsroom($NR, ~nr_sk)
  , Fr(~j_sig_sk)
  , Fr(~j_fetch_sk)
  , Fr(~j_enc_sk) ]
  --[ Journalist_Verified($NR, $J)
    , OnlyOnce($J) ]->
  [ Out(<<j_sig_pk, j_enc_pk, j_fetch_pk>, sig_j_pk>)
  , !Journalist_Enrolled($NR, $J)
  , !Ltk_Journalist_SIG_Key($J, ~j_sig_sk)
  , !Ltk_Journalist_Enc_Key($J, ~j_enc_sk)
  , !Ltk_Journalist_Fetch_Key($J, ~j_fetch_sk)
  , !Journalist_Signature($NR, $J, <j_sig_pk, j_enc_pk, j_fetch_pk>, sig_j_pk) ]

rule Reveal_Journalist_SIG_Key [color=#FF6961]:
  let j_sig_pk = pk(~j_sig_sk)
  in
  [ !Ltk_Journalist_SIG_Key($A, ~j_sig_sk) ]
  --[ Reveal_Journalist_SIG_Key($A)
    , Reveal_Journalist_SIG_Key(j_sig_pk)
    , SomeCompromise() ]->
  [ Out(~j_sig_sk) ]

rule Reveal_Journalist_Fetch_Key [color=#FF6961]:
  let j_fetch_pk = 'g'^~j_fetch_sk
  in
  [ !Ltk_Journalist_Fetch_Key($A, ~j_fetch_sk) ]
  --[ Reveal_Journalist_Fetch_Key($A)
    , Reveal_Journalist_Fetch_Key(j_fetch_pk)
    , SomeCompromise() ]->
  [ Out(~j_fetch_sk) ]

rule Reveal_Journalist_Enc_Key [color=#FF6961]:
  let j_enc_pk = 'g'^~j_enc_sk
  in
  [ !Ltk_Journalist_Enc_Key($A, ~j_enc_sk) ]
  --[ Reveal_Journalist_Enc_Key($A)
    , Reveal_Journalist_Enc_Key(j_enc_pk)
    , SomeCompromise() ]->
  [ Out(~j_enc_sk) ]

rule Journalist_Register_EEnc_Key [color=#FF7F50]:
  let je_enc_pk = pk(~je_enc_sk)
      sig_je_pk = sign(<'ephemeral', je_enc_pk>, ~j_sig_sk)
  in
  [ !Ltk_Journalist_SIG_Key($J, ~j_sig_sk)
  , Fr(~je_enc_sk) ]
  -->
  [ Out(<je_enc_pk, sig_je_pk>)
  , Journalist_Ephemeral_Key($J, ~je_enc_sk)
  , Journalist_EEnc_Key_Reveal($J, ~je_enc_sk) ]

rule Reveal_Journalist_EEnc_Key [color=#FF6961]:
  let je_enc_pk = pk(~je_enc_sk)
  in
  [ Journalist_EEnc_Key_Reveal($A, ~je_enc_sk) ]
  --[ Reveal_Journalist_EEnc_Key($A)
    , Reveal_Journalist_EEnc_Key(je_enc_pk)
    , SomeCompromise() ]->
  [ Out(~je_enc_sk) ]

// Messaging and Fetching Protocol

rule Source_Send [color=#6495ED]:
  let s_enc_sk = kdf(<'Enc', ~passphrase>)
      s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      s_enc_pk = pk(s_enc_sk)
      s_fetch_pk = 'g'^s_fetch_sk
      m =  <'msg_s2j', ~msg, s_enc_pk, s_fetch_pk, j_sig_pk, j_fetch_pk, $NR>
      c = AuthEnc(s_enc_sk, je_enc_pk, m)
      me_pk = 'g'^~me_sk
      m_gdh = j_fetch_pk^~me_sk
  in
  [ !Ltk_Source_Passphrase($S, ~passphrase)
  , !Pk_Newsroom($NR, nr_pk)
  , !Newsroom_Server($NR, $Server)
  , In(<<j_sig_pk, j_enc_pk, j_fetch_pk>, sig_j_pk, je_enc_pk, sig_je_pk>)
  , Fr(~me_sk)
  , Fr(~msg)
  , Fr(~sess) ]
  --[ // check signatures of journalist's longterm signature and ephemeral encryption keys
      Eq(verify(sig_j_pk, <'signature', j_sig_pk, j_enc_pk, j_fetch_pk>, nr_pk), true)
    , Eq(verify(sig_je_pk, <'ephemeral', je_enc_pk>, j_sig_pk), true)
      // Actions for Lemmas
    , Source_Sent(s_enc_pk, j_sig_pk, j_fetch_pk, je_enc_pk, $NR, c, m)
    , Encryption_OUT($Server, m)
    ]->
  [ Client_Out(~sess, $Server, <'ciphertext', <c, s_enc_pk, me_pk, m_gdh>>) ]

rule Journalist_Fetch_Messages [color=#B4D9EF]:
  [ Fr(~sess)
  , !Journalist_Enrolled($NR, $J)
  , !Newsroom_Server($NR, $Server) ]
  -->
  [ Client_Out(~sess, $Server, 'fetch_messages')
  , !Journalist_Fetched_Messages($J, $NR, $Server, ~sess) ]

rule Journalist_Solve_Fetch_Challenge [derivchecks, color=#B4D9EF]:
  let pmgdh = ('g'^~me_sk)^~re_sk
      kmid = pmgdh^~j_fetch_sk
  in
  [ !Journalist_Fetched_Messages($J, $NR, $Server, ~sess)
  , !Ltk_Journalist_Fetch_Key($J, ~j_fetch_sk)
  , Client_In(~sess, $Server, <'challenge', <senc(~id, kmid), pmgdh>>) ]
  --[ DHElement_Check(kmid)
    , DHElement_Check(pmgdh) ]->
  [ Client_Out(~sess, $Server, <'solution', ~id>) ]

rule Journalist_Recv [derivchecks, color=#6495ED]:
  let j_sig_pk = pk(~j_sig_sk)
      // m =  <'msg_s2j', msg, s_enc_pk, s_fetch_pk, j_sig_pk, j_fetch_pk, $NR>
      j_fetch_pk = 'g'^~j_fetch_sk
      je_enc_pk = pk(~je_enc_sk)
      m = AuthDec(s_enc_pk, ~je_enc_sk, c)
      s_fetch_pk = 4th(m)
  in
  [ Client_In(~sess, $Server, <'ciphertext', <c, s_enc_pk>>)
  , !Journalist_Fetched_Messages($J, $NR, $Server, ~sess)
  , Journalist_Ephemeral_Key($J, ~je_enc_sk)
  , !Ltk_Journalist_SIG_Key($J, ~j_sig_sk)
  , !Ltk_Journalist_Fetch_Key($J, ~j_fetch_sk) ]
  --[ // Actions for Lemmas
      Journalist_Received(j_sig_pk, j_fetch_pk, je_enc_pk, $NR, s_enc_pk, c, m)
    , Encryption_IN($Server, m)
    , Eq(fst(m), 'msg_s2j')
    , Eq(3rd(m), s_enc_pk)
    , Eq(5th(m), j_sig_pk)
    , Eq(6th(m), j_fetch_pk)
    , Eq(last7th(m), $NR)
    ]->
  [ Journalist_Recv($J, $NR, s_enc_pk, s_fetch_pk, m) ]

rule Journalist_Send [color=#6495ED]:
  let j_sig_pk = pk(~j_sig_sk)
      j_enc_pk = pk(~j_enc_sk)
      m = <'msg_j2s', ~msg, s_enc_pk, s_fetch_pk, j_sig_pk, j_enc_pk, j_fetch_pk, sig_j_pk, $NR>
      c = AuthEnc(~j_enc_sk, s_enc_pk, m)
      me_pk = 'g'^~me_sk
      m_gdh = s_fetch_pk^~me_sk
  in
  [ Journalist_Recv($J, $NR, s_enc_pk, s_fetch_pk, m_old)
  , !Ltk_Journalist_SIG_Key($J, ~j_sig_sk)
  , !Ltk_Journalist_Enc_Key($J, ~j_enc_sk)
  , !Journalist_Signature($NR, $J, <j_sig_pk, j_enc_pk, j_fetch_pk>, sig_j_pk)
  , !Newsroom_Server($NR, $Server)
  , Fr(~me_sk)
  , Fr(~msg)
  , Fr(~sess) ]
  --[ // Actions for Lemmas
      Journalist_Response(j_sig_pk, j_enc_pk, $NR, s_enc_pk, s_fetch_pk, m_old, c, m)
    , Encryption_OUT($Server, m)
    ]->
  [ Client_Out(~sess, $Server, <'ciphertext', <c, j_enc_pk, me_pk, m_gdh>>) ]

rule Source_Fetch_Messages [color=#B4D9EF]:
  [ Fr(~sess)
  , !Newsroom_Server($NR, $Server) ]
  -->
  [ Client_Out(~sess, $Server, 'fetch_messages')
  , !Source_Fetched_Messages($S, $Server, ~sess) ]

rule Source_Solve_Fetch_Challenge [derivchecks, color=#B4D9EF]:
  let s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      pmgdh = ('g'^~me_sk)^~re_sk
      kmid = pmgdh^s_fetch_sk
  in
  [ !Source_Fetched_Messages($S, $Server, ~sess)
  , !Ltk_Source_Passphrase($S, ~passphrase)
  , Client_In(~sess, $Server, <'challenge', <senc(~id, kmid), pmgdh>>) ]
  --[ DHElement_Check(kmid)
    , DHElement_Check(pmgdh) ]->
  [ Client_Out(~sess, $Server, <'solution', ~id>) ]

rule Source_Recv [color=#6495ED, derivchecks]:
  let s_enc_sk = kdf(<'Enc', ~passphrase>)
      s_fetch_sk = kdf(<'Fetch', ~passphrase>)
      s_enc_pk = pk(s_enc_sk)
      s_fetch_pk = 'g'^s_fetch_sk
      // m = <'msg_j2s', ~msg, s_enc_pk, s_fetch_pk, j_sig_pk, j_enc_pk, j_fetch_pk, sig_j_pk, $NR>
      m = AuthDec(j_enc_pk, s_enc_sk, c)
      j_sig_pk = 5th(m)
      j_fetch_pk = 7th(m)
      sig_j_pk = 8th(m)
  in
  [ !Source_Fetched_Messages($S, $Server, ~sess)
  , Client_In(~sess, $Server, <'ciphertext', <c, j_enc_pk>>)
  , !Ltk_Source_Passphrase($S, ~passphrase)
  , !Pk_Newsroom($NR, nr_pk) ]
  --[ Eq(verify(sig_j_pk, <'signature', <j_sig_pk, j_enc_pk, j_fetch_pk>>, nr_pk), true)
    , Eq(fst(m), 'msg_j2s')
    , Eq(3rd(m), s_enc_pk)
    , Eq(4th(m), s_fetch_pk)
    , Eq(6th(m), j_enc_pk)
    , Eq(last9th(m), $NR)
      // Actions for Lemmas
    , Source_Received(s_enc_pk, s_fetch_pk, j_sig_pk, j_enc_pk, $NR, c, m)
    , Encryption_IN($Server, m)
    ]->
  []

restriction Eq:
  "All t1 t2 #x. Eq(t1, t2) @ #x ==> t1 = t2"

restriction DHElement_Check:
  "All x #t. DHElement_Check(x) @ #t ==> not(x = 'g' | x = DH_neutral)"

restriction OnlyOnce:
  "All x #i #j. OnlyOnce(x)@#i & OnlyOnce(x)@#j ==> #i = #j"

lemma Encryption [sources]:
"All server m #t.
        Encryption_IN(server, m) @ #t
  ==>   (Ex #x. KU(m) @ #x & #x < #t)
      | (Ex #x. Encryption_OUT(server, m) @ #x & #x < #t)"

lemma Auto_Executability_Submission:
exists-trace
"Ex #t1 #t2 s_enc_pk j_sig_pk j_fetch_pk je_enc_pk nr c m.
        Source_Sent(s_enc_pk, j_sig_pk, j_fetch_pk, je_enc_pk, nr, c, m) @ #t1
      & Journalist_Received(j_sig_pk, j_fetch_pk, je_enc_pk, nr, s_enc_pk, c, m) @ #t2
      & (not Ex #x. SomeCompromise() @ #x)"

// nicht automatisch verifizierbar
lemma Secrecy_Source_Ciphertext:
"All #t s_enc_pk j_sig_pk j_fetch_pk je_enc_pk nr c m. 
        Source_Sent(s_enc_pk, j_sig_pk, j_fetch_pk, je_enc_pk, nr, c, m) @ #t
  ==>   (not Ex #x. K(c) @ #x)
      | (  (Ex #x. Reveal_Journalist_Fetch_Key(j_fetch_pk) @ #x)
         | (Ex #x. Reveal_Newsroom_Key(nr) @ #x & #x < #t))"

lemma Auto_Injective_Agreement_Source_Message:
"All j_sig_pk j_fetch_pk je_enc_pk nr s_enc_pk c m #t1 #t2.
        Journalist_Received(j_sig_pk, j_fetch_pk, je_enc_pk, nr, s_enc_pk, c, m) @ #t1
      & Register_Source(s_enc_pk) @ #t2
  ==> (Ex #x1. Source_Sent(s_enc_pk, j_sig_pk, j_fetch_pk, je_enc_pk, nr, c, m) @ #x1 
              & #x1 < #t1
              & not (Ex j_sig_pk_2 j_fetch_pk_2 je_enc_pk_2 nr_2 s_enc_pk_2 c_2 #x2. Journalist_Received(j_sig_pk_2, j_fetch_pk_2, je_enc_pk_2, nr_2, s_enc_pk_2, c_2, m) @ #x2 & not (#x2 = #t1)))
      | (Ex #x. Reveal_Source_Enc_Key(s_enc_pk) @ #x)"

// not automatically verifiable
lemma Executability_Journalist_Response:
exists-trace
"Ex #t1 #t2 s_enc_pk s_fetch_pk j_sig_pk j_enc_pk nr m_old c m.
        Journalist_Response(j_sig_pk, j_enc_pk, nr, s_enc_pk, s_fetch_pk, m_old, c, m) @ #t1
      & Source_Received(s_enc_pk, s_fetch_pk, j_sig_pk, j_enc_pk, nr, c, m) @ #t2
      & (not Ex #x. SomeCompromise() @ #x)"

lemma Secrecy_Journalist_Ciphertext:
"All #t1 #t2 #t3 s_enc_pk s_fetch_pk j_sig_pk j_enc_pk j_fetch_pk je_enc_pk nr c_old m_old c m. 
        Source_Sent(s_enc_pk, j_sig_pk, j_fetch_pk, je_enc_pk, nr, c_old, m_old) @ #t1
      & Journalist_Received(j_sig_pk, j_fetch_pk, je_enc_pk, nr, s_enc_pk, c_old, m_old) @ #t2
      & Journalist_Response(j_sig_pk, j_enc_pk, nr, s_enc_pk, s_fetch_pk, m_old, c, m) @ #t3
  ==>   (not Ex #x. K(c) @ #x)
      | (Ex #x. Reveal_Source_Fetch_Key(s_fetch_pk) @ #x)"

lemma Auto_Non_Injective_Agreement_Journalist_Message:
"All #t1 s_enc_pk s_fetch_pk j_sig_pk j_enc_pk nr c m.
        Source_Received(s_enc_pk, s_fetch_pk, j_sig_pk, j_enc_pk, nr, c, m) @ #t1
  ==>   (Ex m_old #x. Journalist_Response(j_sig_pk, j_enc_pk, nr, s_enc_pk, s_fetch_pk, m_old, c, m) @ #x & #x < #t1) 
      | (Ex #x. Reveal_Newsroom_Key(nr) @ #x)
      | (Ex #x. Reveal_Journalist_Enc_Key(j_enc_pk) @ #x)"

end