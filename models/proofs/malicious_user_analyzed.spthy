theory SecureDrop begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: fst/1, kdf/1, pair/2, pk/1, sdec/2, senc/2, sign/2,
           snd/1, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



heuristic: o "./oracles/malicious_user.py"







rule (modulo E) PQAttackerStart[color=#ff6961]:
   [ ] --[ PQAttack( ), SomeCompromise( ) ]-> [ !PQAttacker( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) PQAttacker[color=#ff6961]:
   [ !PQAttacker( ), !NonPQSecKey( k ) ] --> [ Out( k ) ]

  /* has exactly the trivial AC variant */

restriction PQAttacker:
  "∀ #compr #t.
    ((PQAttack( ) @ #compr) ∧ (PrePQAttack( ) @ #t)) ⇒ (#t < #compr)"
  // safety formula

rule (modulo E) ClientOut[color=#ffffff]:
   [ Client_Out( ~sess, $Server, msg ), !Message_Server( $Server ) ]
  -->
   [ !Client( ~sess, $Server, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) AdversaryClientOut[color=#ff6961]:
   [ In( ~sess ), In( msg ), !Message_Server( $Server ) ]
  -->
   [ !Client( ~sess, $Server, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ServerOut[color=#ffffff]:
   [ Server_Out( ~sess, $Server, msg ), !Message_Server( $Server ) ]
  -->
   [ !Server( ~sess, $Server, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ClientToServer[color=#ffffff]:
   [ !Client( ~sess, $Server, msg ) ]
  -->
   [ Server_In( ~sess, $Server, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ServerToClient[color=#ffffff]:
   [ !Server( ~sess, $Server, msg ) ]
  -->
   [ Client_In( ~sess, $Server, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ServerToAdversaryClient[color=#ff6961]:
   [ In( adversarySess ), !Server( adversarySess, $Server, msg ) ]
  --[ AdversaryActivity( ) ]->
   [ Out( msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Server_Ciphertext:
   [ Server_In( ~sess, $Server, <'ciphertext', c> ) ]
  --[
  Ciphertext_IN( ~sess, $Server, <'ciphertext', c> ), PrePQAttack( )
  ]->
   [ !Stored_Ciphertext( $Server, c ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Server_Receive_Fetch_Request:
   [ Server_In( ~sess, $Server, 'fetch_messages' ) ]
  --[ PrePQAttack( ) ]->
   [ Server_Fetched_Messages( ~sess, $Server ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Server_Create_Challenge[derivchecks]:
   [
   Server_Fetched_Messages( ~sess, $Server ),
   !Stored_Ciphertext( $Server, <c, 'g'^~me_sk, m_gdh> ),
   Fr( ~re_sk ), Fr( ~id )
   ]
  --[
  DHElement_Check( m_gdh^~re_sk ), DHElement_Check( 'g'^~me_sk ),
  DHElement_Check( 'g'^~me_sk^~re_sk ), PrePQAttack( )
  ]->
   [
   Stored_Ciphertext_Challenge( $Server, ~sess, ~id, c ),
   Server_Out( ~sess, $Server,
               <'challenge', senc(~id, m_gdh^~re_sk), 'g'^~me_sk^~re_sk>
   ),
   !NonPQSecKey( ~re_sk )
   ]

  /*
  rule (modulo AC) Server_Create_Challenge[derivchecks]:
     [
     Server_Fetched_Messages( ~sess, $Server ),
     !Stored_Ciphertext( $Server, <c, 'g'^~x, m_gdh> ), Fr( ~re_sk ),
     Fr( ~id )
     ]
    --[
    DHElement_Check( z ), DHElement_Check( 'g'^~x ),
    DHElement_Check( 'g'^(~re_sk*~x) ), PrePQAttack( )
    ]->
     [
     Stored_Ciphertext_Challenge( $Server, ~sess, ~id, c ),
     Server_Out( ~sess, $Server,
                 <'challenge', senc(~id, z), 'g'^(~re_sk*~x)>
     ),
     !NonPQSecKey( ~re_sk )
     ]
    variants (modulo AC)
    1. ~re_sk
             = ~re_sk.32
       m_gdh = m_gdh.35
       z     = m_gdh.35^~re_sk.32
    
    2. ~re_sk
             = ~re_sk.32
       m_gdh = z.38^inv(~re_sk.32)
       z     = z.38
    
    3. ~re_sk
             = ~re_sk.159
       m_gdh = x.312^x.313
       z     = x.312^(~re_sk.159*x.313)
    
    4. ~re_sk
             = ~re_sk.162
       m_gdh = x.318^inv((~re_sk.162*x.319))
       z     = x.318^inv(x.319)
    
    5. ~re_sk
             = ~re_sk.162
       m_gdh = x.318^(x.319*inv(~re_sk.162))
       z     = x.318^x.319
    
    6. ~re_sk
             = ~re_sk.163
       m_gdh = x.319^(x.320*inv((~re_sk.163*x.321)))
       z     = x.319^(x.320*inv(x.321))
    
    7. m_gdh = DH_neutral
       z     = DH_neutral
  */

rule (modulo E) Server_Challenge_Response:
   [
   Stored_Ciphertext_Challenge( $Server, ~sess, ~id, c ),
   Server_In( ~sess, $Server, <'solution', ~id> )
   ]
  --[ PrePQAttack( ) ]->
   [ Server_Out( ~sess, $Server, <'ciphertext', c> ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Register_Newsroom_Key[color=#ff7f50]:
   [ Fr( ~ltk ) ]
  --[ OnlyOnce( $A ), OnlyOnce( $Server ), PrePQAttack( ) ]->
   [
   !Ltk_Newsroom( $A, ~ltk ), !Pk_Newsroom( $A, pk(~ltk) ),
   !Newsroom_Server( $A, $Server ), !Message_Server( $Server ),
   !NonPQSecKey( ~ltk ), Out( pk(~ltk) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_Newsroom_Key[color=#ff6961]:
   [ !Ltk_Newsroom( A, ~ltk ) ]
  --[ Reveal_Newsroom_Key( A ), SomeCompromise( ) ]->
   [ Out( ~ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Register_Source_Keys[color=#fdfd96]:
   [ Fr( ~passphrase ) ]
  --[
  Register_Source( 'g'^kdf(<'Fetch', ~passphrase>) ), OnlyOnce( $A ),
  PrePQAttack( )
  ]->
   [
   !Ltk_Source_Passphrase( $A, ~passphrase ),
   Ltk_Source_Fetch_Key_Reveal( $A, kdf(<'Fetch', ~passphrase>) ),
   !NonPQSecKey( kdf(<'Fetch', ~passphrase>) ),
   Out( 'g'^kdf(<'Fetch', ~passphrase>) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_Source_Fetch_Key[color=#ff6961]:
   [ Ltk_Source_Fetch_Key_Reveal( $A, s_fetch_sk ) ]
  --[
  Reveal_Source_Fetch_Key( $A ),
  Reveal_Source_Fetch_Key( 'g'^s_fetch_sk ), SomeCompromise( )
  ]->
   [ Out( s_fetch_sk ) ]

  /*
  rule (modulo AC) Reveal_Source_Fetch_Key[color=#ff6961]:
     [ Ltk_Source_Fetch_Key_Reveal( $A, s_fetch_sk ) ]
    --[
    Reveal_Source_Fetch_Key( $A ), Reveal_Source_Fetch_Key( z ),
    SomeCompromise( )
    ]->
     [ Out( s_fetch_sk ) ]
    variants (modulo AC)
    1. s_fetch_sk
             = s_fetch_sk.4
       z     = 'g'^s_fetch_sk.4
    
    2. s_fetch_sk
             = one
       z     = 'g'
  */

rule (modulo E) Journalist_Enrollment[color=#ff7f50]:
   [ !Ltk_Newsroom( $NR, ~nr_sk ), Fr( ~j_fetch_sk ) ]
  --[ Journalist_Verified( $NR, $J ), OnlyOnce( $J ), PrePQAttack( )
  ]->
   [
   Out( <'g'^~j_fetch_sk, 
         sign(<'signature', $J, 'g'^~j_fetch_sk>, ~nr_sk)>
   ),
   !Journalist_Enrolled( $NR, $J ),
   !Ltk_Journalist_Fetch_Key( $J, ~j_fetch_sk ),
   !NonPQSecKey( ~j_fetch_sk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_Journalist_Fetch_Key[color=#ff6961]:
   [ !Ltk_Journalist_Fetch_Key( $A, ~j_fetch_sk ) ]
  --[
  Reveal_Journalist_Fetch_Key( $A ),
  Reveal_Journalist_Fetch_Key( 'g'^~j_fetch_sk ), SomeCompromise( )
  ]->
   [ Out( ~j_fetch_sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Source_Send[derivchecks, color=#6495ed]:
   [
   !Ltk_Source_Passphrase( $S, ~passphrase ),
   !Pk_Newsroom( $NR, nr_pk ), !Newsroom_Server( $NR, $Server ),
   In( <j_fetch_pk, sig_j_pk> ), Fr( ~x ), Fr( ~msg ), Fr( ~sess )
   ]
  --[
  Eq( verify(sig_j_pk, <'signature', $J, j_fetch_pk>, nr_pk), true ),
  Source_Sent( $S, $J, $NR,
               <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>
  ),
  Ciphertext_OUT( ~sess, $Server,
                  <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>
  ),
  PrePQAttack( )
  ]->
   [
   Client_Out( ~sess, $Server,
               <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                'g'^~x, j_fetch_pk^~x>
   ),
   !NonPQSecKey( ~x )
   ]

  /*
  rule (modulo AC) Source_Send[derivchecks, color=#6495ed]:
     [
     !Ltk_Source_Passphrase( $S, ~passphrase ),
     !Pk_Newsroom( $NR, nr_pk ), !Newsroom_Server( $NR, $Server ),
     In( <j_fetch_pk, sig_j_pk> ), Fr( ~x ), Fr( ~msg ), Fr( ~sess )
     ]
    --[
    Eq( z.1, true ),
    Source_Sent( $S, $J, $NR,
                 <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>
    ),
    Ciphertext_OUT( ~sess, $Server,
                    <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>
    ),
    PrePQAttack( )
    ]->
     [
     Client_Out( ~sess, $Server,
                 <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                  'g'^~x, z>
     ),
     !NonPQSecKey( ~x )
     ]
    variants (modulo AC)
     1. $J    = $J.37
        ~x    = ~x.44
        j_fetch_pk
              = j_fetch_pk.45
        nr_pk = nr_pk.46
        sig_j_pk
              = sig_j_pk.47
        z     = j_fetch_pk.45^~x.44
        z.1   = verify(sig_j_pk.47, <'signature', $J.37, j_fetch_pk.45>,
                       nr_pk.46)
    
     2. $J    = $J.37
        j_fetch_pk
              = DH_neutral
        nr_pk = nr_pk.46
        sig_j_pk
              = sig_j_pk.47
        z     = DH_neutral
        z.1   = verify(sig_j_pk.47, <'signature', $J.37, DH_neutral>,
                       nr_pk.46)
    
     3. $J    = $J.41
        ~x    = ~x.48
        j_fetch_pk
              = z.55^inv(~x.48)
        nr_pk = nr_pk.50
        sig_j_pk
              = sig_j_pk.51
        z     = z.55
        z.1   = verify(sig_j_pk.51, <'signature', $J.41, z.55^inv(~x.48)>,
                       nr_pk.50)
    
     4. $J    = $J.263
        ~x    = ~x.270
        j_fetch_pk
              = x.523^x.524
        nr_pk = nr_pk.272
        sig_j_pk
              = sig_j_pk.273
        z     = x.523^(~x.270*x.524)
        z.1   = verify(sig_j_pk.273, <'signature', $J.263, x.523^x.524>,
                       nr_pk.272)
    
     5. $J    = $J.264
        ~x    = ~x.271
        j_fetch_pk
              = x.525^inv((~x.271*x.526))
        nr_pk = nr_pk.273
        sig_j_pk
              = sig_j_pk.274
        z     = x.525^inv(x.526)
        z.1   = verify(sig_j_pk.274,
                       <'signature', $J.264, x.525^inv((~x.271*x.526))>, nr_pk.273)
    
     6. $J    = $J.264
        ~x    = ~x.271
        j_fetch_pk
              = x.525^(x.526*inv(~x.271))
        nr_pk = nr_pk.273
        sig_j_pk
              = sig_j_pk.274
        z     = x.525^x.526
        z.1   = verify(sig_j_pk.274,
                       <'signature', $J.264, x.525^(x.526*inv(~x.271))>, nr_pk.273)
    
     7. $J    = $J.265
        ~x    = ~x.272
        j_fetch_pk
              = x.526^(x.527*inv((~x.272*x.528)))
        nr_pk = nr_pk.274
        sig_j_pk
              = sig_j_pk.275
        z     = x.526^(x.527*inv(x.528))
        z.1   = verify(sig_j_pk.275,
                       <'signature', $J.265, x.526^(x.527*inv((~x.272*x.528)))>,
                       nr_pk.274)
    
     8. $J    = $J.270
        j_fetch_pk
              = DH_neutral
        nr_pk = pk(x.538)
        sig_j_pk
              = sign(<'signature', $J.270, DH_neutral>, x.538)
        z     = DH_neutral
        z.1   = true
    
     9. $J    = $J.271
        ~x    = ~x.278
        j_fetch_pk
              = j_fetch_pk.279
        nr_pk = pk(x.540)
        sig_j_pk
              = sign(<'signature', $J.271, j_fetch_pk.279>, x.540)
        z     = j_fetch_pk.279^~x.278
        z.1   = true
    
    10. $J    = $J.271
        ~x    = ~x.278
        j_fetch_pk
              = z.285^inv(~x.278)
        nr_pk = pk(x.540)
        sig_j_pk
              = sign(<'signature', $J.271, z.285^inv(~x.278)>, x.540)
        z     = z.285
        z.1   = true
    
    11. $J    = $J.272
        ~x    = ~x.279
        j_fetch_pk
              = x.540^x.541
        nr_pk = pk(x.542)
        sig_j_pk
              = sign(<'signature', $J.272, x.540^x.541>, x.542)
        z     = x.540^(~x.279*x.541)
        z.1   = true
    
    12. $J    = $J.272
        ~x    = ~x.279
        j_fetch_pk
              = x.540^inv((~x.279*x.541))
        nr_pk = pk(x.542)
        sig_j_pk
              = sign(<'signature', $J.272, x.540^inv((~x.279*x.541))>, x.542)
        z     = x.540^inv(x.541)
        z.1   = true
    
    13. $J    = $J.272
        ~x    = ~x.279
        j_fetch_pk
              = x.540^(x.541*inv(~x.279))
        nr_pk = pk(x.542)
        sig_j_pk
              = sign(<'signature', $J.272, x.540^(x.541*inv(~x.279))>, x.542)
        z     = x.540^x.541
        z.1   = true
    
    14. $J    = $J.273
        ~x    = ~x.280
        j_fetch_pk
              = x.541^(x.542*inv((~x.280*x.543)))
        nr_pk = pk(x.544)
        sig_j_pk
              = sign(<'signature', $J.273, x.541^(x.542*inv((~x.280*x.543)))>,
                     x.544)
        z     = x.541^(x.542*inv(x.543))
        z.1   = true
  */

rule (modulo E) Journalist_Fetch_Messages[color=#b4d9ef]:
   [
   Fr( ~sess ), !Journalist_Enrolled( $NR, $J ),
   !Newsroom_Server( $NR, $Server )
   ]
  --[ PrePQAttack( ) ]->
   [
   Client_Out( ~sess, $Server, 'fetch_messages' ),
   !Journalist_Fetched_Messages( $J, $NR, $Server, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Journalist_Solve_Fetch_Challenge[derivchecks,
                                                 color=#b4d9ef]:
   [
   !Journalist_Fetched_Messages( $J, $NR, $Server, ~sess ),
   !Ltk_Journalist_Fetch_Key( $J, ~j_fetch_sk ),
   Client_In( ~sess, $Server,
              <'challenge', senc(~id, 'g'^~me_sk^~re_sk^~j_fetch_sk), 
               'g'^~me_sk^~re_sk>
   )
   ]
  --[
  DHElement_Check( 'g'^~me_sk^~re_sk^~j_fetch_sk ),
  DHElement_Check( 'g'^~me_sk^~re_sk ), PrePQAttack( )
  ]->
   [ Client_Out( ~sess, $Server, <'solution', ~id> ) ]

  /*
  rule (modulo AC) Journalist_Solve_Fetch_Challenge[derivchecks,
                                                    color=#b4d9ef]:
     [
     !Journalist_Fetched_Messages( $J, $NR, $Server, ~sess ),
     !Ltk_Journalist_Fetch_Key( $J, ~j_fetch_sk ),
     Client_In( ~sess, $Server,
                <'challenge', senc(~id, 'g'^(~j_fetch_sk*~me_sk*~re_sk)), 
                 'g'^(~me_sk*~re_sk)>
     )
     ]
    --[
    DHElement_Check( 'g'^(~j_fetch_sk*~me_sk*~re_sk) ),
    DHElement_Check( 'g'^(~me_sk*~re_sk) ), PrePQAttack( )
    ]->
     [ Client_Out( ~sess, $Server, <'solution', ~id> ) ]
  */

rule (modulo E) Journalist_Recv[color=#6495ed]:
   [
   Client_In( ~sess, $Server, <'ciphertext', ~msg, $S, s_fetch_pk> ),
   !Journalist_Fetched_Messages( $J, $NR, $Server, ~sess )
   ]
  --[
  Journalist_Received( $J, $NR, $S, <~msg, $S, s_fetch_pk> ),
  PrePQAttack( )
  ]->
   [
   Journalist_Recv( $J, $NR, $S, s_fetch_pk, <~msg, $S, s_fetch_pk> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Journalist_Send[color=#6495ed]:
   [
   Journalist_Recv( $J, $NR, $S, s_fetch_pk, m_old ),
   !Newsroom_Server( $NR, $Server ), Fr( ~x ), Fr( ~msg ), Fr( ~sess )
   ]
  --[
  Journalist_Response( $J, s_fetch_pk, m_old, <~msg, $J> ),
  Ciphertext_OUT( ~sess, $Server, <~msg, $J> ), PrePQAttack( )
  ]->
   [
   Client_Out( ~sess, $Server,
               <'ciphertext', <~msg, $J>, 'g'^~x, s_fetch_pk^~x>
   ),
   !NonPQSecKey( ~x )
   ]

  /*
  rule (modulo AC) Journalist_Send[color=#6495ed]:
     [
     Journalist_Recv( $J, $NR, $S, s_fetch_pk, m_old ),
     !Newsroom_Server( $NR, $Server ), Fr( ~x ), Fr( ~msg ), Fr( ~sess )
     ]
    --[
    Journalist_Response( $J, s_fetch_pk, m_old, <~msg, $J> ),
    Ciphertext_OUT( ~sess, $Server, <~msg, $J> ), PrePQAttack( )
    ]->
     [
     Client_Out( ~sess, $Server, <'ciphertext', <~msg, $J>, 'g'^~x, z>
     ),
     !NonPQSecKey( ~x )
     ]
    variants (modulo AC)
    1. ~x    = ~x.16
       s_fetch_pk
             = s_fetch_pk.18
       z     = s_fetch_pk.18^~x.16
    
    2. ~x    = ~x.19
       s_fetch_pk
             = z.24^inv(~x.19)
       z     = z.24
    
    3. ~x    = ~x.49
       s_fetch_pk
             = x.89^x.90
       z     = x.89^(~x.49*x.90)
    
    4. ~x    = ~x.51
       s_fetch_pk
             = x.93^inv((~x.51*x.94))
       z     = x.93^inv(x.94)
    
    5. ~x    = ~x.51
       s_fetch_pk
             = x.93^(x.94*inv(~x.51))
       z     = x.93^x.94
    
    6. ~x    = ~x.52
       s_fetch_pk
             = x.94^(x.95*inv((~x.52*x.96)))
       z     = x.94^(x.95*inv(x.96))
    
    7. s_fetch_pk
             = DH_neutral
       z     = DH_neutral
  */

rule (modulo E) Source_Fetch_Messages[color=#b4d9ef]:
   [ Fr( ~sess ), !Newsroom_Server( $NR, $Server ) ]
  --[ PrePQAttack( ) ]->
   [
   Client_Out( ~sess, $Server, 'fetch_messages' ),
   !Source_Fetched_Messages( $S, $Server, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Source_Solve_Fetch_Challenge[derivchecks,
                                             color=#b4d9ef]:
   [
   !Source_Fetched_Messages( $S, $Server, ~sess ),
   !Ltk_Source_Passphrase( $S, ~passphrase ),
   Client_In( ~sess, $Server,
              <'challenge', 
               senc(~id, 'g'^~me_sk^~re_sk^kdf(<'Fetch', ~passphrase>)), 
               'g'^~me_sk^~re_sk>
   )
   ]
  --[
  DHElement_Check( 'g'^~me_sk^~re_sk^kdf(<'Fetch', ~passphrase>) ),
  DHElement_Check( 'g'^~me_sk^~re_sk ), PrePQAttack( )
  ]->
   [ Client_Out( ~sess, $Server, <'solution', ~id> ) ]

  /*
  rule (modulo AC) Source_Solve_Fetch_Challenge[derivchecks,
                                                color=#b4d9ef]:
     [
     !Source_Fetched_Messages( $S, $Server, ~sess ),
     !Ltk_Source_Passphrase( $S, ~passphrase ),
     Client_In( ~sess, $Server,
                <'challenge', 
                 senc(~id, 'g'^(~me_sk*~re_sk*kdf(<'Fetch', ~passphrase>))), 
                 'g'^(~me_sk*~re_sk)>
     )
     ]
    --[
    DHElement_Check( 'g'^(~me_sk*~re_sk*kdf(<'Fetch', ~passphrase>)) ),
    DHElement_Check( 'g'^(~me_sk*~re_sk) ), PrePQAttack( )
    ]->
     [ Client_Out( ~sess, $Server, <'solution', ~id> ) ]
  */

rule (modulo E) Source_Recv[color=#6495ed]:
   [
   !Source_Fetched_Messages( $S, $Server, ~sess ),
   Client_In( ~sess, $Server, <'ciphertext', ~msg, $J> ),
   !Ltk_Source_Passphrase( $S, ~passphrase ),
   !Pk_Newsroom( $NR, nr_pk )
   ]
  --[
  Source_Received( 'g'^kdf(<'Fetch', ~passphrase>), $J, <~msg, $J> ),
  PrePQAttack( )
  ]->
   [ ]

  /* has exactly the trivial AC variant */

restriction Eq:
  "∀ t1 t2 #x. (Eq( t1, t2 ) @ #x) ⇒ (t1 = t2)"
  // safety formula

restriction DHElement_Check:
  "∀ x #t.
    (DHElement_Check( x ) @ #t) ⇒ (¬((x = 'g') ∨ (x = DH_neutral)))"
  // safety formula

restriction OnlyOnce:
  "∀ x #i #j.
    ((OnlyOnce( x ) @ #i) ∧ (OnlyOnce( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma Auto_Ciphertext [sources]:
  all-traces
  "∀ #t1 sess server c X m_gdh.
    (Ciphertext_IN( sess, server, <'ciphertext', c, X, m_gdh>
     ) @ #t1) ⇒
    ((∃ #t2. Ciphertext_OUT( sess, server, c ) @ #t2) ∨
     (∃ #t2. (!KU( c ) @ #t2) ∧ (#t2 < #t1)))"
/*
guarded formula characterizing all counter-examples:
"∃ #t1 sess server c X m_gdh.
  (Ciphertext_IN( sess, server, <'ciphertext', c, X, m_gdh> ) @ #t1)
 ∧
  (∀ #t2. (Ciphertext_OUT( sess, server, c ) @ #t2) ⇒ ⊥) ∧
  (∀ #t2. (!KU( c ) @ #t2) ⇒ ¬(#t2 < #t1))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#t1))  ∥
         (∃ #t2.
           (Ciphertext_OUT( ~sess, $Server, c ) @ #t2) ∧ ¬(last(#t2)))  ∥
         (∃ #t2. (!KU( c ) @ #t2) ∧ (¬(last(#t2))) ∧ (#t2 < #t1)) )
    case case_1
    solve( Server_In( ~sess, $Server, <'ciphertext', c, X, m_gdh>
           ) ▶₀ #t1 )
      case ClientToServer_case_1
      by contradiction /* from formulas */
    next
      case ClientToServer_case_2
      by contradiction /* from formulas */
    next
      case ClientToServer_case_3
      by contradiction /* from formulas */
    qed
  next
    case case_2
    by contradiction /* from formulas */
  next
    case case_3
    by contradiction /* from formulas */
  qed
qed

lemma Auto_Executability_Submission:
  exists-trace
  "∃ #t1 #t2 s j nr c.
    ((Source_Sent( s, j, nr, c ) @ #t1) ∧
     (Journalist_Received( j, nr, s, c ) @ #t2)) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ #t1 #t2 s j nr c.
  (Source_Sent( s, j, nr, c ) @ #t1) ∧
  (Journalist_Received( j, nr, s, c ) @ #t2)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
simplify
solve( !Ltk_Source_Passphrase( $S, ~passphrase ) ▶₀ #t1 )
  case Register_Source_Keys
  solve( !Pk_Newsroom( $NR, pk(x) ) ▶₁ #t1 )
    case Register_Newsroom_Key
    solve( !Newsroom_Server( $NR, $Server ) ▶₂ #t1 )
      case Register_Newsroom_Key
      solve( Client_In( ~sess.1, $Server.1,
                        <'ciphertext', ~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>
             ) ▶₀ #t2 )
        case ServerToClient
        solve( !Journalist_Fetched_Messages( $J, $NR, $Server.1, ~sess.1
               ) ▶₁ #t2 )
          case Journalist_Fetch_Messages
          solve( !KU( sign(<'signature', $J, j_fetch_pk>, ~ltk) ) @ #vk.2 )
            case Journalist_Enrollment
            solve( Server_In( ~sess.1, $Server, <'solution', ~id> ) ▶₁ #vr.4 )
              case ClientToServer_case_1
              solve( Server_In( ~sess.1, $Server, 'fetch_messages' ) ▶₀ #vr.6 )
                case ClientToServer_case_1
                solve( Server_In( ~sess.2, $Server,
                                  <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                                   'g'^~x.1, 'g'^(~j_fetch_sk*~x.1)>
                       ) ▶₀ #vr.7 )
                  case ClientToServer_case_1
                  solve( !KU( 'g'^~j_fetch_sk ) @ #vk.2 )
                    case Journalist_Enrollment
                    SOLVED // trace found
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma Auto_Secrecy_Source_Ciphertext:
  all-traces
  "∀ #t s j nr c.
    (Source_Sent( s, j, nr, c ) @ #t) ⇒
    ((¬(∃ #x. K( c ) @ #x)) ∨
     ((∃ #x. Reveal_Journalist_Fetch_Key( j ) @ #x) ∨
      (∃ #x. (Reveal_Newsroom_Key( nr ) @ #x) ∧ (#x < #t))))"
/*
guarded formula characterizing all counter-examples:
"∃ #t s j nr c.
  (Source_Sent( s, j, nr, c ) @ #t)
 ∧
  (∃ #x. (K( c ) @ #x)) ∧
  (∀ #x. (Reveal_Journalist_Fetch_Key( j ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (Reveal_Newsroom_Key( nr ) @ #x) ⇒ ¬(#x < #t))"
*/
simplify
solve( !Ltk_Source_Passphrase( $S, ~passphrase ) ▶₀ #t )
  case Register_Source_Keys
  solve( !Pk_Newsroom( $NR, pk(x) ) ▶₁ #t )
    case Register_Newsroom_Key
    solve( !Newsroom_Server( $NR, $Server ) ▶₂ #t )
      case Register_Newsroom_Key
      solve( !KU( sign(<'signature', $J, j_fetch_pk>, ~ltk) ) @ #vk.2 )
        case Journalist_Enrollment
        solve( !KU( ~msg ) @ #vk.4 )
          case ServerToAdversaryClient_case_1
          solve( Server_In( ~sess, $Server,
                            <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                             'g'^~x.2, m_gdh>
                 ) ▶₀ #vr.10 )
            case ClientToServer
            by contradiction /* cyclic */
          qed
        next
          case ServerToAdversaryClient_case_2
          solve( Server_In( ~sess, $Server,
                            <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                             'g'^~x.2, z^inv(~re_sk)>
                 ) ▶₀ #vr.10 )
            case ClientToServer
            by contradiction /* cyclic */
          qed
        next
          case ServerToAdversaryClient_case_3
          solve( Server_In( ~sess, $Server,
                            <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                             'g'^~x.2, x.3^x.4>
                 ) ▶₀ #vr.10 )
            case ClientToServer_case_1
            solve( Server_In( ~sess.1, $Server, <'solution', ~id> ) ▶₁ #vr.6 )
              case ClientToServer_case_1
              by solve( !KU( ~sess.1 ) @ #vk.8 )
            next
              case ClientToServer_case_2
              by solve( !KU( ~sess.1 ) @ #vk.8 )
            next
              case ClientToServer_case_3
              solve( !KU( ~id ) @ #vk.11 )
                case ServerToAdversaryClient
                solve( !KU( 'g'^(~j_fetch_sk*~re_sk*~x) ) @ #vk.12 )
                  case Journalist_Enrollment
                  solve( !KU( ~re_sk ) @ #vk.14 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  qed
                next
                  case ServerToAdversaryClient_case_1
                  solve( !KU( ~j_fetch_sk ) @ #vk.13 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  next
                    case Reveal_Journalist_Fetch_Key
                    by contradiction /* from formulas */
                  qed
                next
                  case ServerToAdversaryClient_case_2
                  solve( !KU( ~re_sk.1 ) @ #vk.17 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  qed
                next
                  case ServerToAdversaryClient_case_3
                  solve( !KU( ~re_sk.1 ) @ #vk.17 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  qed
                next
                  case ServerToAdversaryClient_case_4
                  solve( !KU( ~re_sk.1 ) @ #vk.17 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  qed
                next
                  case ServerToAdversaryClient_case_5
                  solve( !KU( ~j_fetch_sk ) @ #vk.17 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  next
                    case Reveal_Journalist_Fetch_Key
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( !KU( ~re_sk ) @ #vk.16 )
                    case PQAttacker
                    by contradiction /* cyclic */
                  qed
                qed
              qed
            qed
          next
            case ClientToServer_case_2
            by contradiction /* cyclic */
          qed
        next
          case ServerToAdversaryClient_case_4
          solve( Server_In( ~sess, $Server,
                            <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                             'g'^~x.2, x.3^inv((~re_sk*x.4))>
                 ) ▶₀ #vr.10 )
            case ClientToServer
            by contradiction /* cyclic */
          qed
        next
          case ServerToAdversaryClient_case_5
          solve( Server_In( ~sess, $Server,
                            <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                             'g'^~x.2, x.3^(x.4*inv(~re_sk))>
                 ) ▶₀ #vr.10 )
            case ClientToServer
            by contradiction /* cyclic */
          qed
        next
          case ServerToAdversaryClient_case_6
          solve( Server_In( ~sess, $Server,
                            <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                             'g'^~x.2, x.3^(x.4*inv((~re_sk*x.5)))>
                 ) ▶₀ #vr.10 )
            case ClientToServer
            by contradiction /* cyclic */
          qed
        qed
      next
        case c_sign
        solve( !KU( ~ltk ) @ #vk.10 )
          case PQAttacker
          by contradiction /* cyclic */
        next
          case Reveal_Newsroom_Key
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed

lemma Auto_Executability_Journalist_Response:
  exists-trace
  "∃ #t1 #t2 s j c_old c.
    ((Journalist_Response( j, s, c_old, c ) @ #t1) ∧
     (Source_Received( s, j, c ) @ #t2)) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ #t1 #t2 s j c_old c.
  (Journalist_Response( j, s, c_old, c ) @ #t1) ∧
  (Source_Received( s, j, c ) @ #t2)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
simplify
solve( Journalist_Recv( $J, $NR, $S,
                        'g'^kdf(<'Fetch', ~passphrase>), c_old
       ) ▶₀ #t1 )
  case Journalist_Recv
  solve( !Newsroom_Server( $NR, $Server ) ▶₁ #t1 )
    case Register_Newsroom_Key
    solve( !Source_Fetched_Messages( $S.1, $Server.1, ~sess.1
           ) ▶₀ #t2 )
      case Source_Fetch_Messages
      solve( Client_In( ~sess.1, $Server.1, <'ciphertext', ~msg.1, $J>
             ) ▶₁ #t2 )
        case ServerToClient
        solve( !Ltk_Source_Passphrase( $S.1, ~passphrase ) ▶₂ #t2 )
          case Register_Source_Keys
          solve( !Pk_Newsroom( $NR.1, nr_pk ) ▶₃ #t2 )
            case Register_Newsroom_Key
            solve( Server_In( ~sess.2, $Server, <'solution', ~id> ) ▶₁ #vr.6 )
              case ClientToServer_case_1
              solve( Server_In( ~sess.2, $Server, 'fetch_messages' ) ▶₀ #vr.8 )
                case ClientToServer_case_1
                solve( Server_In( ~sess.3, $Server,
                                  <'ciphertext', <~msg, $S, 'g'^kdf(<'Fetch', ~passphrase>)>, 
                                   'g'^~x.1, 'g'^(~j_fetch_sk*~x.1)>
                       ) ▶₀ #vr.9 )
                  case ClientToServer_case_1
                  solve( Server_In( ~sess.1, $Server.1, <'solution', ~id.1>
                         ) ▶₁ #vr.14 )
                    case ClientToServer_case_1
                    solve( Server_In( ~sess.1, $Server.1, 'fetch_messages'
                           ) ▶₀ #vr.16 )
                      case ClientToServer_case_1
                      solve( Server_In( ~sess.4, $Server.1,
                                        <'ciphertext', <~msg.1, $J>, 'g'^~x.2, 
                                         'g'^(~x.2*kdf(<'Fetch', ~passphrase>))>
                             ) ▶₀ #vr.17 )
                        case ClientToServer_case_1
                        solve( !KU( 'g'^~j_fetch_sk ) @ #vk.1 )
                          case Journalist_Enrollment
                          solve( !KU( sign(<'signature', $J.1, 'g'^~j_fetch_sk>, ~nr_sk)
                                 ) @ #vk.2 )
                            case Journalist_Enrollment
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma Auto_Secrecy_Journalist_Ciphertext:
  all-traces
  "∀ #t1 #t2 s j c_old c.
    ((Journalist_Response( j, s, c_old, c ) @ #t1) ∧
     (Register_Source( s ) @ #t2)) ⇒
    ((¬(∃ #x. K( c ) @ #x)) ∨
     (∃ #x. Reveal_Source_Fetch_Key( s ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ #t1 #t2 s j c_old c.
  (Journalist_Response( j, s, c_old, c ) @ #t1) ∧
  (Register_Source( s ) @ #t2)
 ∧
  (∃ #x. (K( c ) @ #x)) ∧
  (∀ #x. (Reveal_Source_Fetch_Key( s ) @ #x) ⇒ ⊥)"
*/
simplify
solve( !Newsroom_Server( $NR, $Server ) ▶₁ #t1 )
  case Register_Newsroom_Key
  solve( Journalist_Recv( $J, $NR, $S,
                          'g'^kdf(<'Fetch', ~passphrase>), c_old
         ) ▶₀ #t1 )
    case Journalist_Recv
    solve( Server_In( ~sess.1, $Server, <'solution', ~id> ) ▶₁ #vr.6 )
      case ClientToServer_case_1
      solve( !KU( ~msg.1 ) @ #vk.1 )
        case ServerToAdversaryClient_case_1
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, m_gdh>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_2
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, z^inv(~re_sk.1)>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_3
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, x.4^x.5>
               ) ▶₀ #vr.21 )
          case ClientToServer_case_1
          solve( Server_In( ~sess.2, $Server, <'solution', ~id.1>
                 ) ▶₁ #vr.17 )
            case ClientToServer_case_1
            by solve( !KU( ~sess.2 ) @ #vk.3 )
          next
            case ClientToServer_case_2
            by solve( !KU( ~sess.2 ) @ #vk.3 )
          next
            case ClientToServer_case_3
            solve( !KU( ~id.1 ) @ #vk.6 )
              case ServerToAdversaryClient
              solve( !KU( 'g'^(~x*~re_sk.1*kdf(<'Fetch', ~passphrase>))
                     ) @ #vk.7 )
                case Register_Source_Keys
                solve( !KU( ~re_sk ) @ #vk.10 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_01
                solve( !KU( kdf(<'Fetch', ~passphrase>) ) @ #vk.8 )
                  case PQAttacker
                  by contradiction /* cyclic */
                next
                  case Reveal_Source_Fetch_Key
                  by contradiction /* from formulas */
                next
                  case c_kdf
                  by solve( !KU( ~passphrase ) @ #vk.11 )
                qed
              next
                case ServerToAdversaryClient_case_02
                solve( !KU( ~re_sk.2 ) @ #vk.12 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_03
                solve( !KU( ~re_sk.2 ) @ #vk.12 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_04
                solve( !KU( kdf(<'Fetch', ~passphrase>) ) @ #vk.12 )
                  case PQAttacker
                  by contradiction /* cyclic */
                next
                  case Reveal_Source_Fetch_Key
                  by contradiction /* from formulas */
                next
                  case c_kdf
                  by solve( !KU( ~passphrase ) @ #vk.15 )
                qed
              next
                case ServerToAdversaryClient_case_05
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_06
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_07
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_08
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_09
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_10
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case c_exp
                solve( !KU( ~re_sk ) @ #vk.11 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              qed
            qed
          qed
        next
          case ClientToServer_case_2
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_4
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, x.4^inv((~re_sk.1*x.5))>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_5
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, x.4^(x.5*inv(~re_sk.1))>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_6
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, 
                           x.4^(x.5*inv((~re_sk.1*x.6)))>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      qed
    next
      case ClientToServer_case_2
      solve( !KU( ~msg.1 ) @ #vk.1 )
        case ServerToAdversaryClient_case_1
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, m_gdh>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_2
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, z^inv(~re_sk.1)>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_3
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, x.4^x.5>
               ) ▶₀ #vr.21 )
          case ClientToServer_case_1
          solve( Server_In( ~sess.2, $Server, <'solution', ~id.1>
                 ) ▶₁ #vr.17 )
            case ClientToServer_case_1
            by solve( !KU( ~sess.2 ) @ #vk.3 )
          next
            case ClientToServer_case_2
            by solve( !KU( ~sess.2 ) @ #vk.3 )
          next
            case ClientToServer_case_3
            solve( !KU( ~id.1 ) @ #vk.6 )
              case ServerToAdversaryClient
              solve( !KU( 'g'^(~x*~re_sk.1*kdf(<'Fetch', ~passphrase>))
                     ) @ #vk.7 )
                case Register_Source_Keys
                solve( !KU( ~re_sk ) @ #vk.10 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_01
                solve( !KU( kdf(<'Fetch', ~passphrase>) ) @ #vk.8 )
                  case PQAttacker
                  by contradiction /* cyclic */
                next
                  case Reveal_Source_Fetch_Key
                  by contradiction /* from formulas */
                next
                  case c_kdf
                  by solve( !KU( ~passphrase ) @ #vk.11 )
                qed
              next
                case ServerToAdversaryClient_case_02
                solve( !KU( ~re_sk.2 ) @ #vk.12 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_03
                solve( !KU( ~re_sk.2 ) @ #vk.12 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_04
                solve( !KU( kdf(<'Fetch', ~passphrase>) ) @ #vk.12 )
                  case PQAttacker
                  by contradiction /* cyclic */
                next
                  case Reveal_Source_Fetch_Key
                  by contradiction /* from formulas */
                next
                  case c_kdf
                  by solve( !KU( ~passphrase ) @ #vk.15 )
                qed
              next
                case ServerToAdversaryClient_case_05
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_06
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_07
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_08
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_09
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case ServerToAdversaryClient_case_10
                solve( !KU( ~re_sk ) @ #vk.14 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              next
                case c_exp
                solve( !KU( ~re_sk ) @ #vk.11 )
                  case PQAttacker
                  by contradiction /* cyclic */
                qed
              qed
            qed
          qed
        next
          case ClientToServer_case_2
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_4
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, x.4^inv((~re_sk.1*x.5))>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_5
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, x.4^(x.5*inv(~re_sk.1))>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      next
        case ServerToAdversaryClient_case_6
        solve( Server_In( ~sess, $Server,
                          <'ciphertext', <~msg.1, $J>, 'g'^~x.3, 
                           x.4^(x.5*inv((~re_sk.1*x.6)))>
               ) ▶₀ #vr.21 )
          case ClientToServer
          by contradiction /* cyclic */
        qed
      qed
    next
      case ClientToServer_case_3
      by solve( !KU( ~sess.1 ) @ #vk.3 )
    qed
  qed
qed





















/*
WARNING: the following wellformedness checks failed!

Derivation Checks
=================

  Derivation checks timed out. Use --derivcheck-timeout=INT to configure timeout, 0 to deactivate.
*/

/*
Generated from:
Tamarin version 1.8.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2023-08-30 13:15:41.590881948 UTC
*/

end